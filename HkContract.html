// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract LottoChainDecentralizedHKPool {
    address public owner;
    uint256 public minBet = 1;
    uint256 public maxBet = 99;
    uint256 public ethBetPrice = 0.000175 ether;

    struct Bet {
        address player;
        uint256 number;
        uint256 betAmount;
        bool isETH;
    }

    struct Comment {
        address user;
        string text;
        uint256 likes;
    }

    mapping(uint256 => Bet[]) public bets;
    mapping(address => uint256) public ethWinnings;
    mapping(uint256 => uint256) public results;
    mapping(uint256 => Comment[]) public comments;

    event BetPlaced(address indexed player, uint256 number, uint256 betAmount, bool isETH);
    event WinnerSetETH(address indexed winner, uint256 amount);
    event LotteryResult(uint256 indexed drawId, uint256 number);
    event CommentAdded(uint256 indexed drawId, address user, string text);
    event CommentEdited(uint256 indexed drawId, address user, uint256 commentIndex, string newText);
    event CommentDeleted(uint256 indexed drawId, address user, uint256 commentIndex);
    event LikeAdded(uint256 indexed drawId, address user, uint256 commentIndex);
    event ReceivedETH(address indexed sender, uint256 amount);
    event ETHWithdrawn(address indexed owner, uint256 amount);
    event WithdrawETH(address indexed sender, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    function placeBet(uint256 _number, uint256 _times, bool _isETH) external payable {
        require(_number >= 0 && _number <= 9999, "Invalid number (0 - 9999)");
        require(_times >= minBet && _times <= maxBet, "Bet count out of range");

        uint256 totalCost = _times * ethBetPrice;
        require(msg.value == totalCost, "Incorrect ETH amount");

        bets[_number].push(Bet(msg.sender, _number, _times, _isETH));
        emit BetPlaced(msg.sender, _number, _times, _isETH);
    }

    function setWinnerETH(address _winner, uint256 _amount) external onlyOwner {
        ethWinnings[_winner] += _amount;
        emit WinnerSetETH(_winner, _amount);
    }

    function claimETH() external {
        uint256 amount = ethWinnings[msg.sender];
        require(amount > 0, "No ETH winnings");
    
        ethWinnings[msg.sender] = 0;
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "ETH transfer failed");

        emit WithdrawETH(msg.sender, amount);
    }

    function setLotteryResult(uint256 _drawId, uint256 _number) external onlyOwner {
        results[_drawId] = _number;
        emit LotteryResult(_drawId, _number);
    }

    function addComment(uint256 _drawId, string memory _text) external {
        comments[_drawId].push(Comment(msg.sender, _text, 0));
        emit CommentAdded(_drawId, msg.sender, _text);
    }

    function editComment(uint256 _drawId, uint256 _commentIndex, string memory _newText) external {
        require(comments[_drawId][_commentIndex].user == msg.sender, "Not your comment");
        comments[_drawId][_commentIndex].text = _newText;
        emit CommentEdited(_drawId, msg.sender, _commentIndex, _newText);
    }

    function deleteComment(uint256 _drawId, uint256 _commentIndex) external {
        require(comments[_drawId][_commentIndex].user == msg.sender, "Not your comment");
        delete comments[_drawId][_commentIndex];
        emit CommentDeleted(_drawId, msg.sender, _commentIndex);
    }

    function likeComment(uint256 _drawId, uint256 _commentIndex) external {
        comments[_drawId][_commentIndex].likes++;
        emit LikeAdded(_drawId, msg.sender, _commentIndex);
    }

    function contractETHBalance() external view returns (uint256) {
       return address(this).balance;
    }

    function executeWithdrawETH(uint256 _amount) external onlyOwner {
        require(address(this).balance >= _amount, "Insufficient ETH balance");

        (bool success, ) = payable(owner).call{value: _amount}("");
        require(success, "ETH withdrawal failed");

        emit WithdrawETH(msg.sender, _amount);
    }



    receive() external payable {
        emit ReceivedETH(msg.sender, msg.value);
    }
}
